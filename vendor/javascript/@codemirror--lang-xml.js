// @codemirror/lang-xml@6.1.0 downloaded from https://ga.jspm.io/npm:@codemirror/lang-xml@6.1.0/dist/index.js

import{parser as e}from"@lezer/xml";import{syntaxTree as t,indentNodeProp as n,foldNodeProp as l,bracketMatchingHandle as o,LRLanguage as a,LanguageSupport as r}from"@codemirror/language";import{EditorSelection as i}from"@codemirror/state";import{EditorView as m}from"@codemirror/view";function tagName(e,t){let n=t&&t.getChild("TagName");return n?e.sliceString(n.from,n.to):""}function elementName$1(e,t){let n=t&&t.firstChild;return n&&n.name=="OpenTag"?tagName(e,n):""}function attrName(e,t,n){let l=t&&t.getChildren("Attribute").find((e=>e.from<=n&&e.to>=n));let o=l&&l.getChild("AttributeName");return o?e.sliceString(o.from,o.to):""}function findParentElement(e){for(let t=e&&e.parent;t;t=t.parent)if(t.name=="Element")return t;return null}function findLocation(e,n){var l;let o=t(e).resolveInner(n,-1),a=null;for(let e=o;!a&&e.parent;e=e.parent)e.name!="OpenTag"&&e.name!="CloseTag"&&e.name!="SelfClosingTag"&&e.name!="MismatchedCloseTag"||(a=e);if(a&&(a.to>n||a.lastChild.type.isError)){let e=a.parent;if(o.name=="TagName")return a.name=="CloseTag"||a.name=="MismatchedCloseTag"?{type:"closeTag",from:o.from,context:e}:{type:"openTag",from:o.from,context:findParentElement(e)};if(o.name=="AttributeName")return{type:"attrName",from:o.from,context:a};if(o.name=="AttributeValue")return{type:"attrValue",from:o.from,context:a};let t=o==a||o.name=="Attribute"?o.childBefore(n):o;return(t===null||t===void 0?void 0:t.name)=="StartTag"?{type:"openTag",from:n,context:findParentElement(e)}:(t===null||t===void 0?void 0:t.name)=="StartCloseTag"&&t.to<=n?{type:"closeTag",from:n,context:e}:(t===null||t===void 0?void 0:t.name)=="Is"?{type:"attrValue",from:n,context:a}:t?{type:"attrName",from:n,context:a}:null}if(o.name=="StartCloseTag")return{type:"closeTag",from:n,context:o.parent};while(o.parent&&o.to==n&&!((l=o.lastChild)===null||l===void 0?void 0:l.type.isError))o=o.parent;return o.name=="Element"||o.name=="Text"||o.name=="Document"?{type:"tag",from:n,context:o.name=="Element"?o:findParentElement(o)}:null}class Element{constructor(e,t,n){this.attrs=t;this.attrValues=n;this.children=[];this.name=e.name;this.completion=Object.assign(Object.assign({type:"type"},e.completion||{}),{label:this.name});this.openCompletion=Object.assign(Object.assign({},this.completion),{label:"<"+this.name});this.closeCompletion=Object.assign(Object.assign({},this.completion),{label:"</"+this.name+">",boost:2});this.closeNameCompletion=Object.assign(Object.assign({},this.completion),{label:this.name+">"});this.text=e.textContent?e.textContent.map((e=>({label:e,type:"text"}))):[]}}const s=/^[:\-\.\w\u00b7-\uffff]*$/;function attrCompletion(e){return Object.assign(Object.assign({type:"property"},e.completion||{}),{label:e.name})}function valueCompletion(e){return typeof e=="string"?{label:`"${e}"`,type:"constant"}:/^"/.test(e.label)?e:Object.assign(Object.assign({},e),{label:`"${e.label}"`})}function completeFromSchema(e,t){let n=[],l=[];let o=Object.create(null);for(let e of t){let t=attrCompletion(e);n.push(t);e.global&&l.push(t);e.values&&(o[e.name]=e.values.map(valueCompletion))}let a=[],r=[];let i=Object.create(null);for(let t of e){let e=l,m=o;t.attributes&&(e=e.concat(t.attributes.map((e=>{if(typeof e=="string")return n.find((t=>t.label==e))||{label:e,type:"property"};if(e.values){m==o&&(m=Object.create(m));m[e.name]=e.values.map(valueCompletion)}return attrCompletion(e)}))));let s=new Element(t,e,m);i[s.name]=s;a.push(s);t.top&&r.push(s)}r.length||(r=a);for(let t=0;t<a.length;t++){let n=e[t],l=a[t];if(n.children)for(let e of n.children)i[e]&&l.children.push(i[e]);else l.children=a}return e=>{var t;let{doc:n}=e.state,m=findLocation(e.state,e.pos);if(!m||m.type=="tag"&&!e.explicit)return null;let{type:c,from:p,context:u}=m;if(c=="openTag"){let e=r;let t=elementName$1(n,u);if(t){let n=i[t];e=(n===null||n===void 0?void 0:n.children)||a}return{from:p,options:e.map((e=>e.completion)),validFor:s}}if(c=="closeTag"){let l=elementName$1(n,u);return l?{from:p,to:e.pos+(n.sliceString(e.pos,e.pos+1)==">"?1:0),options:[((t=i[l])===null||t===void 0?void 0:t.closeNameCompletion)||{label:l+">",type:"type"}],validFor:s}:null}if(c=="attrName"){let e=i[tagName(n,u)];return{from:p,options:(e===null||e===void 0?void 0:e.attrs)||l,validFor:s}}if(c=="attrValue"){let t=attrName(n,u,p);if(!t)return null;let l=i[tagName(n,u)];let a=((l===null||l===void 0?void 0:l.attrValues)||o)[t];return a&&a.length?{from:p,to:e.pos+(n.sliceString(e.pos,e.pos+1)=='"'?1:0),options:a,validFor:/^"[^"]*"?$/}:null}if(c=="tag"){let t=elementName$1(n,u),l=i[t];let o=[],m=u&&u.lastChild;!t||m&&m.name=="CloseTag"&&tagName(n,m)==t||o.push(l?l.closeCompletion:{label:"</"+t+">",type:"type",boost:2});let s=o.concat(((l===null||l===void 0?void 0:l.children)||(u?a:r)).map((e=>e.openCompletion)));if(u&&(l===null||l===void 0?void 0:l.text.length)){let t=u.firstChild;t.to>e.pos-20&&!/\S/.test(e.state.sliceDoc(t.to,e.pos))&&(s=s.concat(l.text))}return{from:p,options:s,validFor:/^<\/?[:\-\.\w\u00b7-\uffff]*$/}}return null}}const c=a.define({name:"xml",parser:e.configure({props:[n.add({Element(e){let t=/^\s*<\//.test(e.textAfter);return e.lineIndent(e.node.from)+(t?0:e.unit)},"OpenTag CloseTag SelfClosingTag"(e){return e.column(e.node.from)+e.unit}}),l.add({Element(e){let t=e.firstChild,n=e.lastChild;return t&&t.name=="OpenTag"?{from:t.to,to:n.name=="CloseTag"?n.from:e.to}:null}}),o.add({"OpenTag CloseTag":e=>e.getChild("TagName")})]}),languageData:{commentTokens:{block:{open:"\x3c!--",close:"--\x3e"}},indentOnInput:/^\s*<\/$/}});function xml(e={}){let t=[c.data.of({autocomplete:completeFromSchema(e.elements||[],e.attributes||[])})];e.autoCloseTags!==false&&t.push(p);return new r(c,t)}function elementName(e,t,n=e.length){if(!t)return"";let l=t.firstChild;let o=l&&l.getChild("TagName");return o?e.sliceString(o.from,Math.min(o.to,n)):""}const p=m.inputHandler.of(((e,n,l,o,a)=>{if(e.composing||e.state.readOnly||n!=l||o!=">"&&o!="/"||!c.isActiveAt(e.state,n,-1))return false;let r=a(),{state:m}=r;let s=m.changeByRange((e=>{var n,l,a;let{head:r}=e;let s=m.doc.sliceString(r-1,r)==o;let c,p=t(m).resolveInner(r,-1);if(s&&o==">"&&p.name=="EndTag"){let t=p.parent;if(((l=(n=t.parent)===null||n===void 0?void 0:n.lastChild)===null||l===void 0?void 0:l.name)!="CloseTag"&&(c=elementName(m.doc,t.parent,r))){let t=r+(m.doc.sliceString(r,r+1)===">"?1:0);let n=`</${c}>`;return{range:e,changes:{from:r,to:t,insert:n}}}}else if(s&&o=="/"&&p.name=="StartCloseTag"){let e=p.parent;if(p.from==r-2&&((a=e.lastChild)===null||a===void 0?void 0:a.name)!="CloseTag"&&(c=elementName(m.doc,e,r))){let e=r+(m.doc.sliceString(r,r+1)===">"?1:0);let t=`${c}>`;return{range:i.cursor(r+t.length,-1),changes:{from:r,to:e,insert:t}}}}return{range:e}}));if(s.changes.empty)return false;e.dispatch([r,m.update(s,{userEvent:"input.complete",scrollIntoView:true})]);return true}));export{p as autoCloseTags,completeFromSchema,xml,c as xmlLanguage};

