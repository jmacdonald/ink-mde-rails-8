// solid-js@1.9.3 downloaded from https://ga.jspm.io/npm:solid-js@1.9.3/dist/solid.js

let e=1,t=false,n=false,r=[],o=null,s=null,u=5,a=0,l=300,c=null,i=null;const f=1073741823;function setupScheduler(){const e=new MessageChannel,t=e.port2;c=()=>t.postMessage(null);e.port1.onmessage=()=>{if(i!==null){const e=performance.now();a=e+u;const n=true;try{const r=i(n,e);r?t.postMessage(null):i=null}catch(e){t.postMessage(null);throw e}}};if(navigator&&navigator.scheduling&&navigator.scheduling.isInputPending){const e=navigator.scheduling;s=()=>{const t=performance.now();return t>=a&&(!!e.isInputPending()||t>=l)}}else s=()=>performance.now()>=a}function enqueue(e,t){function findIndex(){let n=0;let r=e.length-1;while(n<=r){const o=r+n>>1;const s=t.expirationTime-e[o].expirationTime;if(s>0)n=o+1;else{if(!(s<0))return o;r=o-1}}return n}e.splice(findIndex(),0,t)}function requestCallback(o,s){c||setupScheduler();let u=performance.now(),a=f;s&&s.timeout&&(a=s.timeout);const l={id:e++,fn:o,startTime:u,expirationTime:u+a};enqueue(r,l);if(!t&&!n){t=true;i=flushWork;c()}return l}function cancelCallback(e){e.fn=null}function flushWork(e,r){t=false;n=true;try{return workLoop(e,r)}finally{o=null;n=false}}function workLoop(e,t){let n=t;o=r[0]||null;while(o!==null){if(o.expirationTime>n&&(!e||s()))break;const t=o.fn;if(t!==null){o.fn=null;const e=o.expirationTime<=n;t(e);n=performance.now();o===r[0]&&r.shift()}else r.shift();o=r[0]||null}return o!==null}const d={context:void 0,registry:void 0,effects:void 0,done:false,getContextId(){return getContextId(this.context.count)},getNextContextId(){return getContextId(this.context.count++)}};function getContextId(e){const t=String(e),n=t.length-1;return d.context.id+(n?String.fromCharCode(96+n):"")+t}function setHydrateContext(e){d.context=e}function nextHydrateContext(){return{...d.context,id:d.getNextContextId(),count:0}}const equalFn=(e,t)=>e===t;const p=Symbol("solid-proxy");const h=typeof Proxy==="function";const g=Symbol("solid-track");const v=Symbol("solid-dev-component");const m={equals:equalFn};let w=null;let b=runQueue;const y=1;const x=2;const C={owned:null,cleanups:null,context:null,owner:null};const S={};var k=null;let E=null;let O=null;let M=null;let A=null;let P=null;let U=null;let F=0;function createRoot(e,t){const n=A,r=k,o=e.length===0,s=t===void 0?r:t,u=o?C:{owned:null,cleanups:null,context:s?s.context:null,owner:s},a=o?e:()=>e((()=>untrack((()=>cleanNode(u)))));k=u;A=null;try{return runUpdates(a,true)}finally{A=n;k=r}}function createSignal(e,t){t=t?Object.assign({},m,t):m;const n={value:e,observers:null,observerSlots:null,comparator:t.equals||void 0};const setter=e=>{typeof e==="function"&&(e=E&&E.running&&E.sources.has(n)?e(n.tValue):e(n.value));return writeSignal(n,e)};return[readSignal.bind(n),setter]}function createComputed(e,t,n){const r=createComputation(e,t,true,y);O&&E&&E.running?P.push(r):updateComputation(r)}function createRenderEffect(e,t,n){const r=createComputation(e,t,false,y);O&&E&&E.running?P.push(r):updateComputation(r)}function createEffect(e,t,n){b=runUserEffects;const r=createComputation(e,t,false,y),o=T&&useContext(T);o&&(r.suspense=o);n&&n.render||(r.user=true);U?U.push(r):updateComputation(r)}function createReaction(e,t){let n;const r=createComputation((()=>{n?n():untrack(e);n=void 0}),void 0,false,0),o=T&&useContext(T);o&&(r.suspense=o);r.user=true;return e=>{n=e;updateComputation(r)}}function createMemo(e,t,n){n=n?Object.assign({},m,n):m;const r=createComputation(e,t,true,0);r.observers=null;r.observerSlots=null;r.comparator=n.equals||void 0;if(O&&E&&E.running){r.tState=y;P.push(r)}else updateComputation(r);return readSignal.bind(r)}function isPromise(e){return e&&typeof e==="object"&&"then"in e}function createResource(e,t,n){let r;let o;let s;if(arguments.length===2&&typeof t==="object"||arguments.length===1){r=true;o=e;s=t||{}}else{r=e;o=t;s=n||{}}let u=null,a=S,l=null,c=false,i=false,f="initialValue"in s,p=typeof r==="function"&&createMemo(r);const h=new Set,[g,v]=(s.storage||createSignal)(s.initialValue),[m,w]=createSignal(void 0),[b,y]=createSignal(void 0,{equals:false}),[x,C]=createSignal(f?"ready":"unresolved");if(d.context){l=d.getNextContextId();s.ssrLoadFrom==="initial"?a=s.initialValue:d.load&&d.has(l)&&(a=d.load(l))}function loadEnd(e,t,n,r){if(u===e){u=null;r!==void 0&&(f=true);e!==a&&t!==a||!s.onHydrated||queueMicrotask((()=>s.onHydrated(r,{value:t})));a=S;if(E&&e&&c){E.promises.delete(e);c=false;runUpdates((()=>{E.running=true;completeLoad(t,n)}),false)}else completeLoad(t,n)}return t}function completeLoad(e,t){runUpdates((()=>{t===void 0&&v((()=>e));C(t!==void 0?"errored":f?"ready":"unresolved");w(t);for(const e of h.keys())e.decrement();h.clear()}),false)}function read(){const e=T&&useContext(T),t=g(),n=m();if(n!==void 0&&!u)throw n;A&&!A.user&&e&&createComputed((()=>{b();if(u)if(e.resolved&&E&&c)E.promises.add(u);else if(!h.has(e)){e.increment();h.add(e)}}));return t}function load(e=true){if(e!==false&&i)return;i=false;const t=p?p():r;c=E&&E.running;if(t==null||t===false){loadEnd(u,untrack(g));return}E&&u&&E.promises.delete(u);const n=a!==S?a:untrack((()=>o(t,{value:g(),refetching:e})));if(!isPromise(n)){loadEnd(u,n,void 0,t);return n}u=n;if("value"in n){n.status==="success"?loadEnd(u,n.value,void 0,t):loadEnd(u,void 0,castError(n.value),t);return n}i=true;queueMicrotask((()=>i=false));runUpdates((()=>{C(f?"refreshing":"pending");y()}),false);return n.then((e=>loadEnd(n,e,void 0,t)),(e=>loadEnd(n,void 0,castError(e),t)))}Object.defineProperties(read,{state:{get:()=>x()},error:{get:()=>m()},loading:{get(){const e=x();return e==="pending"||e==="refreshing"}},latest:{get(){if(!f)return read();const e=m();if(e&&!u)throw e;return g()}}});p?createComputed((()=>load(false))):load(false);return[read,{refetch:load,mutate:v}]}function createDeferred(e,t){let n,r=t?t.timeoutMs:void 0;const o=createComputation((()=>{n&&n.fn||(n=requestCallback((()=>u((()=>o.value))),r!==void 0?{timeout:r}:void 0));return e()}),void 0,true);const[s,u]=createSignal(E&&E.running&&E.sources.has(o)?o.tValue:o.value,t);updateComputation(o);u((()=>E&&E.running&&E.sources.has(o)?o.tValue:o.value));return s}function createSelector(e,t=equalFn,n){const r=new Map;const o=createComputation((n=>{const o=e();for(const[e,s]of r.entries())if(t(e,o)!==t(e,n))for(const e of s.values()){e.state=y;e.pure?P.push(e):U.push(e)}return o}),void 0,true,y);updateComputation(o);return e=>{const n=A;if(n){let t;(t=r.get(e))?t.add(n):r.set(e,t=new Set([n]));onCleanup((()=>{t.delete(n);!t.size&&r.delete(e)}))}return t(e,E&&E.running&&E.sources.has(o)?o.tValue:o.value)}}function batch(e){return runUpdates(e,false)}function untrack(e){if(!M&&A===null)return e();const t=A;A=null;try{return M?M.untrack(e):e()}finally{A=t}}function on(e,t,n){const r=Array.isArray(e);let o;let s=n&&n.defer;return n=>{let u;if(r){u=Array(e.length);for(let t=0;t<e.length;t++)u[t]=e[t]()}else u=e();if(s){s=false;return n}const a=untrack((()=>t(u,o,n)));o=u;return a}}function onMount(e){createEffect((()=>untrack(e)))}function onCleanup(e){k===null||(k.cleanups===null?k.cleanups=[e]:k.cleanups.push(e));return e}function catchError(e,t){w||(w=Symbol("error"));k=createComputation(void 0,void 0,true);k.context={...k.context,[w]:[t]};E&&E.running&&E.sources.add(k);try{return e()}catch(e){handleError(e)}finally{k=k.owner}}function getListener(){return A}function getOwner(){return k}function runWithOwner(e,t){const n=k;const r=A;k=e;A=null;try{return runUpdates(t,true)}catch(e){handleError(e)}finally{k=n;A=r}}function enableScheduling(e=requestCallback){O=e}function startTransition(e){if(E&&E.running){e();return E.done}const t=A;const n=k;return Promise.resolve().then((()=>{A=t;k=n;let r;if(O||T){r=E||(E={sources:new Set,effects:[],promises:new Set,disposed:new Set,queue:new Set,running:true});r.done||(r.done=new Promise((e=>r.resolve=e)));r.running=true}runUpdates(e,false);A=k=null;return r?r.done:void 0}))}const[q,j]=createSignal(false);function useTransition(){return[q,startTransition]}function resumeEffects(e){U.push.apply(U,e);e.length=0}function createContext(e,t){const n=Symbol("context");return{id:n,Provider:createProvider(n),defaultValue:e}}function useContext(e){let t;return k&&k.context&&(t=k.context[e.id])!==void 0?t:e.defaultValue}function children(e){const t=createMemo(e);const n=createMemo((()=>resolveChildren(t())));n.toArray=()=>{const e=n();return Array.isArray(e)?e:e!=null?[e]:[]};return n}let T;function getSuspenseContext(){return T||(T=createContext())}function enableExternalSource(e,t=(e=>e())){if(M){const{factory:n,untrack:r}=M;M={factory:(t,r)=>{const o=n(t,r);const s=e((e=>o.track(e)),r);return{track:e=>s.track(e),dispose(){s.dispose();o.dispose()}}},untrack:e=>r((()=>t(e)))}}else M={factory:e,untrack:t}}function readSignal(){const e=E&&E.running;if(this.sources&&(e?this.tState:this.state))if((e?this.tState:this.state)===y)updateComputation(this);else{const e=P;P=null;runUpdates((()=>lookUpstream(this)),false);P=e}if(A){const e=this.observers?this.observers.length:0;if(A.sources){A.sources.push(this);A.sourceSlots.push(e)}else{A.sources=[this];A.sourceSlots=[e]}if(this.observers){this.observers.push(A);this.observerSlots.push(A.sources.length-1)}else{this.observers=[A];this.observerSlots=[A.sources.length-1]}}return e&&E.sources.has(this)?this.tValue:this.value}function writeSignal(e,t,n){let r=E&&E.running&&E.sources.has(e)?e.tValue:e.value;if(!e.comparator||!e.comparator(r,t)){if(E){const r=E.running;if(r||!n&&E.sources.has(e)){E.sources.add(e);e.tValue=t}r||(e.value=t)}else e.value=t;e.observers&&e.observers.length&&runUpdates((()=>{for(let t=0;t<e.observers.length;t+=1){const n=e.observers[t];const r=E&&E.running;if(!r||!E.disposed.has(n)){if(r?!n.tState:!n.state){n.pure?P.push(n):U.push(n);n.observers&&markDownstream(n)}r?n.tState=y:n.state=y}}if(P.length>1e6){P=[];false;throw new Error}}),false)}return t}function updateComputation(e){if(!e.fn)return;cleanNode(e);const t=F;runComputation(e,E&&E.running&&E.sources.has(e)?e.tValue:e.value,t);E&&!E.running&&E.sources.has(e)&&queueMicrotask((()=>{runUpdates((()=>{E&&(E.running=true);A=k=e;runComputation(e,e.tValue,t);A=k=null}),false)}))}function runComputation(e,t,n){let r;const o=k,s=A;A=k=e;try{r=e.fn(t)}catch(t){if(e.pure)if(E&&E.running){e.tState=y;e.tOwned&&e.tOwned.forEach(cleanNode);e.tOwned=void 0}else{e.state=y;e.owned&&e.owned.forEach(cleanNode);e.owned=null}e.updatedAt=n+1;return handleError(t)}finally{A=s;k=o}if(!e.updatedAt||e.updatedAt<=n){if(e.updatedAt!=null&&"observers"in e)writeSignal(e,r,true);else if(E&&E.running&&e.pure){E.sources.add(e);e.tValue=r}else e.value=r;e.updatedAt=n}}function createComputation(e,t,n,r=y,o){const s={fn:e,state:r,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:t,owner:k,context:k?k.context:null,pure:n};if(E&&E.running){s.state=0;s.tState=r}k===null||k!==C&&(E&&E.running&&k.pure?k.tOwned?k.tOwned.push(s):k.tOwned=[s]:k.owned?k.owned.push(s):k.owned=[s]);if(M&&s.fn){const[e,t]=createSignal(void 0,{equals:false});const n=M.factory(s.fn,t);onCleanup((()=>n.dispose()));const triggerInTransition=()=>startTransition(t).then((()=>r.dispose()));const r=M.factory(s.fn,triggerInTransition);s.fn=t=>{e();return E&&E.running?r.track(t):n.track(t)}}return s}function runTop(e){const t=E&&E.running;if((t?e.tState:e.state)===0)return;if((t?e.tState:e.state)===x)return lookUpstream(e);if(e.suspense&&untrack(e.suspense.inFallback))return e.suspense.effects.push(e);const n=[e];while((e=e.owner)&&(!e.updatedAt||e.updatedAt<F)){if(t&&E.disposed.has(e))return;(t?e.tState:e.state)&&n.push(e)}for(let r=n.length-1;r>=0;r--){e=n[r];if(t){let t=e,o=n[r+1];while((t=t.owner)&&t!==o)if(E.disposed.has(t))return}if((t?e.tState:e.state)===y)updateComputation(e);else if((t?e.tState:e.state)===x){const t=P;P=null;runUpdates((()=>lookUpstream(e,n[0])),false);P=t}}}function runUpdates(e,t){if(P)return e();let n=false;t||(P=[]);U?n=true:U=[];F++;try{const t=e();completeUpdates(n);return t}catch(e){n||(U=null);P=null;handleError(e)}}function completeUpdates(e){if(P){O&&E&&E.running?scheduleQueue(P):runQueue(P);P=null}if(e)return;let t;if(E)if(E.promises.size||E.queue.size){if(E.running){E.running=false;E.effects.push.apply(E.effects,U);U=null;j(true);return}}else{const e=E.sources;const n=E.disposed;U.push.apply(U,E.effects);t=E.resolve;for(const e of U){"tState"in e&&(e.state=e.tState);delete e.tState}E=null;runUpdates((()=>{for(const e of n)cleanNode(e);for(const t of e){t.value=t.tValue;if(t.owned)for(let e=0,n=t.owned.length;e<n;e++)cleanNode(t.owned[e]);t.tOwned&&(t.owned=t.tOwned);delete t.tValue;delete t.tOwned;t.tState=0}j(false)}),false)}const n=U;U=null;n.length&&runUpdates((()=>b(n)),false);t&&t()}function runQueue(e){for(let t=0;t<e.length;t++)runTop(e[t])}function scheduleQueue(e){for(let t=0;t<e.length;t++){const n=e[t];const r=E.queue;if(!r.has(n)){r.add(n);O((()=>{r.delete(n);runUpdates((()=>{E.running=true;runTop(n)}),false);E&&(E.running=false)}))}}}function runUserEffects(e){let t,n=0;for(t=0;t<e.length;t++){const r=e[t];r.user?e[n++]=r:runTop(r)}if(d.context){if(d.count){d.effects||(d.effects=[]);d.effects.push(...e.slice(0,n));return}setHydrateContext()}if(d.effects&&(d.done||!d.count)){e=[...d.effects,...e];n+=d.effects.length;delete d.effects}for(t=0;t<n;t++)runTop(e[t])}function lookUpstream(e,t){const n=E&&E.running;n?e.tState=0:e.state=0;for(let r=0;r<e.sources.length;r+=1){const o=e.sources[r];if(o.sources){const e=n?o.tState:o.state;e===y?o!==t&&(!o.updatedAt||o.updatedAt<F)&&runTop(o):e===x&&lookUpstream(o,t)}}}function markDownstream(e){const t=E&&E.running;for(let n=0;n<e.observers.length;n+=1){const r=e.observers[n];if(t?!r.tState:!r.state){t?r.tState=x:r.state=x;r.pure?P.push(r):U.push(r);r.observers&&markDownstream(r)}}}function cleanNode(e){let t;if(e.sources)while(e.sources.length){const t=e.sources.pop(),n=e.sourceSlots.pop(),r=t.observers;if(r&&r.length){const e=r.pop(),o=t.observerSlots.pop();if(n<r.length){e.sourceSlots[o]=n;r[n]=e;t.observerSlots[n]=o}}}if(e.tOwned){for(t=e.tOwned.length-1;t>=0;t--)cleanNode(e.tOwned[t]);delete e.tOwned}if(E&&E.running&&e.pure)reset(e,true);else if(e.owned){for(t=e.owned.length-1;t>=0;t--)cleanNode(e.owned[t]);e.owned=null}if(e.cleanups){for(t=e.cleanups.length-1;t>=0;t--)e.cleanups[t]();e.cleanups=null}E&&E.running?e.tState=0:e.state=0}function reset(e,t){if(!t){e.tState=0;E.disposed.add(e)}if(e.owned)for(let t=0;t<e.owned.length;t++)reset(e.owned[t])}function castError(e){return e instanceof Error?e:new Error(typeof e==="string"?e:"Unknown error",{cause:e})}function runErrors(e,t,n){try{for(const n of t)n(e)}catch(e){handleError(e,n&&n.owner||null)}}function handleError(e,t=k){const n=w&&t&&t.context&&t.context[w];const r=castError(e);if(!n)throw r;U?U.push({fn(){runErrors(r,n,t)},state:y}):runErrors(r,n,t)}function resolveChildren(e){if(typeof e==="function"&&!e.length)return resolveChildren(e());if(Array.isArray(e)){const t=[];for(let n=0;n<e.length;n++){const r=resolveChildren(e[n]);Array.isArray(r)?t.push.apply(t,r):t.push(r)}return t}return e}function createProvider(e,t){return function provider(t){let n;createRenderEffect((()=>n=untrack((()=>{k.context={...k.context,[e]:t.value};return children((()=>t.children))}))),void 0);return n}}function onError(e){w||(w=Symbol("error"));if(k===null);else if(k.context!==null&&k.context[w])k.context[w].push(e);else{k.context={...k.context,[w]:[e]};mutateContext(k,w,[e])}}function mutateContext(e,t,n){if(e.owned)for(let r=0;r<e.owned.length;r++){e.owned[r].context===e.context&&mutateContext(e.owned[r],t,n);if(e.owned[r].context){if(!e.owned[r].context[t]){e.owned[r].context[t]=n;mutateContext(e.owned[r],t,n)}}else{e.owned[r].context=e.context;mutateContext(e.owned[r],t,n)}}}function observable(e){return{subscribe(t){if(!(t instanceof Object)||t==null)throw new TypeError("Expected the observer to be an object.");const n=typeof t==="function"?t:t.next&&t.next.bind(t);if(!n)return{unsubscribe(){}};const r=createRoot((t=>{createEffect((()=>{const t=e();untrack((()=>n(t)))}));return t}));getOwner()&&onCleanup(r);return{unsubscribe(){r()}}},[Symbol.observable||"@@observable"](){return this}}}function from(e){const[t,n]=createSignal(void 0,{equals:false});if("subscribe"in e){const t=e.subscribe((e=>n((()=>e))));onCleanup((()=>"unsubscribe"in t?t.unsubscribe():t()))}else{const t=e(n);onCleanup(t)}return t}const H=Symbol("fallback");function dispose(e){for(let t=0;t<e.length;t++)e[t]()}function mapArray(e,t,n={}){let r=[],o=[],s=[],u=0,a=t.length>1?[]:null;onCleanup((()=>dispose(s)));return()=>{let l,c,i=e()||[],f=i.length;i[g];return untrack((()=>{let e,t,d,p,h,g,v,m,w;if(f===0){if(u!==0){dispose(s);s=[];r=[];o=[];u=0;a&&(a=[])}if(n.fallback){r=[H];o[0]=createRoot((e=>{s[0]=e;return n.fallback()}));u=1}}else if(u===0){o=new Array(f);for(c=0;c<f;c++){r[c]=i[c];o[c]=createRoot(mapper)}u=f}else{d=new Array(f);p=new Array(f);a&&(h=new Array(f));for(g=0,v=Math.min(u,f);g<v&&r[g]===i[g];g++);for(v=u-1,m=f-1;v>=g&&m>=g&&r[v]===i[m];v--,m--){d[m]=o[v];p[m]=s[v];a&&(h[m]=a[v])}e=new Map;t=new Array(m+1);for(c=m;c>=g;c--){w=i[c];l=e.get(w);t[c]=l===void 0?-1:l;e.set(w,c)}for(l=g;l<=v;l++){w=r[l];c=e.get(w);if(c!==void 0&&c!==-1){d[c]=o[l];p[c]=s[l];a&&(h[c]=a[l]);c=t[c];e.set(w,c)}else s[l]()}for(c=g;c<f;c++)if(c in d){o[c]=d[c];s[c]=p[c];if(a){a[c]=h[c];a[c](c)}}else o[c]=createRoot(mapper);o=o.slice(0,u=f);r=i.slice(0)}return o}));function mapper(e){s[c]=e;if(a){const[e,n]=createSignal(c);a[c]=n;return t(i[c],e)}return t(i[c])}}}function indexArray(e,t,n={}){let r,o=[],s=[],u=[],a=[],l=0;onCleanup((()=>dispose(u)));return()=>{const c=e()||[],i=c.length;c[g];return untrack((()=>{if(i===0){if(l!==0){dispose(u);u=[];o=[];s=[];l=0;a=[]}if(n.fallback){o=[H];s[0]=createRoot((e=>{u[0]=e;return n.fallback()}));l=1}return s}if(o[0]===H){u[0]();u=[];o=[];s=[];l=0}for(r=0;r<i;r++)r<o.length&&o[r]!==c[r]?a[r]((()=>c[r])):r>=o.length&&(s[r]=createRoot(mapper));for(;r<o.length;r++)u[r]();l=a.length=u.length=i;o=c.slice(0);return s=s.slice(0,l)}));function mapper(e){u[r]=e;const[n,o]=createSignal(c[r]);a[r]=o;return t(n,r)}}}let I=false;function enableHydration(){I=true}function createComponent(e,t){if(I&&d.context){const n=d.context;setHydrateContext(nextHydrateContext());const r=untrack((()=>e(t||{})));setHydrateContext(n);return r}return untrack((()=>e(t||{})))}function trueFn(){return true}const R={get(e,t,n){return t===p?n:e.get(t)},has(e,t){return t===p||e.has(t)},set:trueFn,deleteProperty:trueFn,getOwnPropertyDescriptor(e,t){return{configurable:true,enumerable:true,get(){return e.get(t)},set:trueFn,deleteProperty:trueFn}},ownKeys(e){return e.keys()}};function resolveSource(e){return(e=typeof e==="function"?e():e)?e:{}}function resolveSources(){for(let e=0,t=this.length;e<t;++e){const t=this[e]();if(t!==void 0)return t}}function mergeProps(...e){let t=false;for(let n=0;n<e.length;n++){const r=e[n];t=t||!!r&&p in r;e[n]=typeof r==="function"?(t=true,createMemo(r)):r}if(h&&t)return new Proxy({get(t){for(let n=e.length-1;n>=0;n--){const r=resolveSource(e[n])[t];if(r!==void 0)return r}},has(t){for(let n=e.length-1;n>=0;n--)if(t in resolveSource(e[n]))return true;return false},keys(){const t=[];for(let n=0;n<e.length;n++)t.push(...Object.keys(resolveSource(e[n])));return[...new Set(t)]}},R);const n={};const r=Object.create(null);for(let t=e.length-1;t>=0;t--){const o=e[t];if(!o)continue;const s=Object.getOwnPropertyNames(o);for(let e=s.length-1;e>=0;e--){const t=s[e];if(t==="__proto__"||t==="constructor")continue;const u=Object.getOwnPropertyDescriptor(o,t);if(r[t]){const e=n[t];e&&(u.get?e.push(u.get.bind(o)):u.value!==void 0&&e.push((()=>u.value)))}else r[t]=u.get?{enumerable:true,configurable:true,get:resolveSources.bind(n[t]=[u.get.bind(o)])}:u.value!==void 0?u:void 0}}const o={};const s=Object.keys(r);for(let e=s.length-1;e>=0;e--){const t=s[e],n=r[t];n&&n.get?Object.defineProperty(o,t,n):o[t]=n?n.value:void 0}return o}function splitProps(e,...t){if(h&&p in e){const n=new Set(t.length>1?t.flat():t[0]);const r=t.map((t=>new Proxy({get(n){return t.includes(n)?e[n]:void 0},has(n){return t.includes(n)&&n in e},keys(){return t.filter((t=>t in e))}},R)));r.push(new Proxy({get(t){return n.has(t)?void 0:e[t]},has(t){return!n.has(t)&&t in e},keys(){return Object.keys(e).filter((e=>!n.has(e)))}},R));return r}const n={};const r=t.map((()=>({})));for(const o of Object.getOwnPropertyNames(e)){const s=Object.getOwnPropertyDescriptor(e,o);const u=!s.get&&!s.set&&s.enumerable&&s.writable&&s.configurable;let a=false;let l=0;for(const e of t){if(e.includes(o)){a=true;u?r[l][o]=s.value:Object.defineProperty(r[l],o,s)}++l}a||(u?n[o]=s.value:Object.defineProperty(n,o,s))}return[...r,n]}function lazy(e){let t;let n;const wrap=r=>{const o=d.context;if(o){const[r,s]=createSignal();d.count||(d.count=0);d.count++;(n||(n=e())).then((e=>{!d.done&&setHydrateContext(o);d.count--;s((()=>e.default));setHydrateContext()}));t=r}else if(!t){const[r]=createResource((()=>(n||(n=e())).then((e=>e.default))));t=r}let s;return createMemo((()=>(s=t())?untrack((()=>{false;if(!o||d.done)return s(r);const e=d.context;setHydrateContext(o);const t=s(r);setHydrateContext(e);return t})):""))};wrap.preload=()=>n||((n=e()).then((e=>t=()=>e.default)),n);return wrap}let V=0;function createUniqueId(){const e=d.context;return e?d.getNextContextId():"cl-"+V++}const narrowedError=e=>`Stale read from <${e}>.`;function For(e){const t="fallback"in e&&{fallback:()=>e.fallback};return createMemo(mapArray((()=>e.each),e.children,t||void 0))}function Index(e){const t="fallback"in e&&{fallback:()=>e.fallback};return createMemo(indexArray((()=>e.each),e.children,t||void 0))}function Show(e){const t=e.keyed;const n=createMemo((()=>e.when),void 0,{equals:(e,n)=>t?e===n:!e===!n});return createMemo((()=>{const r=n();if(r){const o=e.children;const s=typeof o==="function"&&o.length>0;return s?untrack((()=>o(t?r:()=>{if(!untrack(n))throw narrowedError("Show");return e.when}))):o}return e.fallback}),void 0,void 0)}function Switch(e){let t=false;const equals=(e,n)=>(t?e[1]===n[1]:!e[1]===!n[1])&&e[2]===n[2];const n=children((()=>e.children)),r=createMemo((()=>{let e=n();Array.isArray(e)||(e=[e]);for(let n=0;n<e.length;n++){const r=e[n].when;if(r){t=!!e[n].keyed;return[n,r,e[n]]}}return[-1]}),void 0,{equals:equals});return createMemo((()=>{const[n,o,s]=r();if(n<0)return e.fallback;const u=s.children;const a=typeof u==="function"&&u.length>0;return a?untrack((()=>u(t?o:()=>{if(untrack(r)[0]!==n)throw narrowedError("Match");return s.when}))):u}),void 0,void 0)}function Match(e){return e}let N;function resetErrorBoundaries(){N&&[...N].forEach((e=>e()))}function ErrorBoundary(e){let t;d.context&&d.load&&(t=d.load(d.getContextId()));const[n,r]=createSignal(t,void 0);N||(N=new Set);N.add(r);onCleanup((()=>N.delete(r)));return createMemo((()=>{let t;if(t=n()){const n=e.fallback;return typeof n==="function"&&n.length?untrack((()=>n(t,(()=>r())))):n}return catchError((()=>e.children),r)}),void 0,void 0)}const suspenseListEquals=(e,t)=>e.showContent===t.showContent&&e.showFallback===t.showFallback;const L=createContext();function SuspenseList(e){let t,[n,r]=createSignal((()=>({inFallback:false})));const o=useContext(L);const[s,u]=createSignal([]);o&&(t=o.register(createMemo((()=>n()().inFallback))));const a=createMemo((n=>{const r=e.revealOrder,o=e.tail,{showContent:u=true,showFallback:a=true}=t?t():{},l=s(),c=r==="backwards";if(r==="together"){const e=l.every((e=>!e()));const t=l.map((()=>({showContent:e&&u,showFallback:a})));t.inFallback=!e;return t}let i=false;let f=n.inFallback;const d=[];for(let e=0,t=l.length;e<t;e++){const n=c?t-e-1:e,r=l[n]();if(i||r){const e=!i;e&&(f=true);d[n]={showContent:e,showFallback:!(o&&(!e||o!=="collapsed"))&&a};i=true}else d[n]={showContent:u,showFallback:a}}i||(f=false);d.inFallback=f;return d}),{inFallback:false});r((()=>a));return createComponent(L.Provider,{value:{register:e=>{let t;u((n=>{t=n.length;return[...n,e]}));return createMemo((()=>a()[t]),void 0,{equals:suspenseListEquals})}},get children(){return e.children}})}function Suspense(e){let t,n,r,o,s,u=0;const[a,l]=createSignal(false),c=getSuspenseContext(),i={increment:()=>{++u===1&&l(true)},decrement:()=>{--u===0&&l(false)},inFallback:a,effects:[],resolved:false},f=getOwner();if(d.context&&d.load){const e=d.getContextId();let t=d.load(e);t&&(typeof t!=="object"||t.status!=="success"?r=t:d.gather(e));if(r&&r!=="$$f"){const[t,u]=createSignal(void 0,{equals:false});o=t;r.then((()=>{if(d.done)return u();d.gather(e);setHydrateContext(n);u();setHydrateContext()}),(e=>{s=e;u()}))}}const p=useContext(L);p&&(t=p.register(i.inFallback));let h;onCleanup((()=>h&&h()));return createComponent(c.Provider,{value:i,get children(){return createMemo((()=>{if(s)throw s;n=d.context;if(o){o();return o=void 0}n&&r==="$$f"&&setHydrateContext();const u=createMemo((()=>e.children));return createMemo((o=>{const s=i.inFallback(),{showContent:a=true,showFallback:l=true}=t?t():{};if((!s||r&&r!=="$$f")&&a){i.resolved=true;h&&h();h=n=r=void 0;resumeEffects(i.effects);return u()}if(l)return h?o:createRoot((t=>{h=t;if(n){setHydrateContext({id:n.id+"F",count:0});n=void 0}return e.fallback}),f)}))}))}})}const D=void 0;export{v as $DEVCOMP,p as $PROXY,g as $TRACK,D as DEV,ErrorBoundary,For,Index,Match,Show,Suspense,SuspenseList,Switch,batch,cancelCallback,catchError,children,createComponent,createComputed,createContext,createDeferred,createEffect,createMemo,createReaction,createRenderEffect,createResource,createRoot,createSelector,createSignal,createUniqueId,enableExternalSource,enableHydration,enableScheduling,equalFn,from,getListener,getOwner,indexArray,lazy,mapArray,mergeProps,observable,on,onCleanup,onError,onMount,requestCallback,resetErrorBoundaries,runWithOwner,d as sharedConfig,splitProps,startTransition,untrack,useContext,useTransition};

